## java 并发编程实践

#### [01 | 可见性、原子性和有序性问题：并发编程Bug的源头](https://time.geekbang.org/column/article/83682)

> 笔记

* 并发安全问题通常是由什么由什么引起的？-> 最终来看是数据结果和预期不一致的问题
    * 可见性 -> 一个线程对另外一个线程的修改是否可见
        * 多核cpu缓存(L1/L2)不一致引起线程不可见
    * 原子性 -> 单个或多个操作的执行不可中断，要么都成功，要么都失败
        * 有的指令不是原子的, 执行过程可以发生线程切换
        * 线程上下文切换导致cpu寄存器指令不一致
    * 有序性 -> 程序按代码顺序执行
        * 编译器优化，编译期在不违法JMM（happens-before) 的原则下进行重排
        * cpu优化，提高cpu利用率
        * 指令重排后，可能引发例如线程拿到未初始化对象之类的问题
            * 如何查看java程序字节码？
                * javap -v xxx.class

* 什么情况下需要注意并发安全问题？
    * 共享变量
    * 发生check-and-do操作
    * 发生read-and-write操作
    * 集合，long型等操作（它们是非原子性操作的时候）
 
> 金句

**在采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避**

举个例子，我们为了对系统实施监控，会引入例如pinpoint之类的AMP组件，解决了监控问题
的同时也带来了性能问题，比如对带宽的占用，增加了接口响应的延时等；再比如，微服务
架构是为了解决单体应用灵活性差等问题而出现，同时也带了了架构的复杂度，增加了服务
之间通信，数据隔离等问题。所以，一个技术在解决某个问题的同时可能带来新的问题，这样
我们可能又会为新的问题引入别的技术来处理，这是个不断循环的过程。因此，我们在评估
一项技术的时候，需要充分考虑其负面影响，怎么权衡利弊，实现利益最大化。


#### [02 | Java内存模型：看Java如何解决可见性和有序性问题](https://time.geekbang.org/column/article/84017)

> 笔记

* 什么是JMM 内存模型?
    * 对cpu缓存，编译器优化等按需禁用的方法和规范
        * 方法-> volatile/synchronized/final
        * 规范 -> Happnes-Before
            * 前一个操作的结果对后一个操作是可见的，即使两个操作不在一个线程
    * 避免缓存，编译器优化等导致的并发安全问题，并交给开放人员控制

* Happens-Before包括哪些规则？
    * 程序顺序性规则
        * 单线程来说，前面的操作总是对后面的操作可见
    * volatile 变量规则
        * 对一个volatile变量的写，总是对它后面的读可见
    * 传递性
        * A 对 B可见，B对C可见，则A对C可见
    * 锁规则
        * 锁释放前的操作，总是对下一次获取锁的操作可见
    * 线程start规则
        * start前的操作，总是对被start的线程操作可见
    * 线程join 规则
        * join线程的操作，总是对join之后的线程操作可见

> 金句

**Happens-Before 的语义本质上是一种可见性，A Happens-Before B 意味着 A 事件对 B 事件来说是可见的，无论 A 事件和 B 事件是否发生在同一个线程里**

以前不是很理解为啥要提出来一个happens-before规则，它为了解决什么问题？实际上它是解决了可见性问题，从而避免因为可见性导致的线程安全问题。
由于缓存，线程切换，指令重排等原因，应用层很难保证多线程读写共享变量的一致性，所以才需要JMM这种机制来约束。即使是这样，它也提供了充分的
灵活性，交给开放人员自己决定怎么使用，例如只有在必要的情况下才使用volatile或synchronized等，这样可以更好的协调性能与安全之间的平衡。
